##### Project code:       171211HSB - HSBC Low Carbon Portfolio
##### Date of last edit:  14/01/2019
##### Code author:        Shyamal Patel
##### Description:        This script reads in coal scenario and exposure data and models stranding impacts
##### Dependencies:       1.  TBC
#####                         Older files can be found in the ".../Dated/" folder
#####                         Input files are generated by 4 - Fossil fuels/Coal/Coal_data_cleaning.R script

#--------------------------------------------------------------------------------------------------

##### SECTION 1 - Housekeeping, data read in and useful functions for saving/writing files, and QA

packages <- c("tidyverse", "magrittr", "readxl", "here", "stringi", "themeVE", "zoo")
lapply(packages, require, character.only = TRUE)

# Define date for save file names
day <- format(Sys.time(), "%d")
month <- match(format(Sys.time(), "%b"), month.abb)
if(nchar(month) == 1) {month <- paste0("0", month)}
year <- substr(format(Sys.time(), "%Y"), 3, 4)
date <- paste0(year, month, day)

# These functions count the number of missing or zero-value observations in a tibble
na_counter <- function(x) {sum(is.na(x))}
zero_counter <- function(x) {sum(ifelse(x == 0, 1, 0))}

# These functions save base, and dated files in the Interim or Output folder for later use
# Dated files are kept for version control purposes
save_dated <- function(data, name, folder, dated = "YES", csv = "NO") {
  main_path <- paste0("1 - Demand destruction/", folder)
  dated_path <- paste0("1 - Demand destruction/", folder, "/Dated/")
  
  # Save main file
  saveRDS(data, here(main_path, paste0(name, ".rds")))
  # Save dated file (optional)
  if(dated == "YES") {saveRDS(data, here(dated_path, paste0(date, "_", name, ".rds")))}
  # Save dated CSV file (optional)
  if(csv == "YES") {write_csv(data, here(dated_path, paste0(date, "_", name, ".csv")))}
}

# Read in company data
company_exposure_data <- readRDS("1 - Demand destruction/Input/Coal_company_data_cleaned.rds")

# Read in cost curve data
supply_curve_data <- readRDS("1 - Demand destruction/Input/Coal_cost_curve_full.rds")

# Read in scenario data
scenario_data <- readRDS("1 - Demand destruction/Input/Coal_scenario_quantities.rds")

# Set discount rate
discount_rate <- 0.0575

#--------------------------------------------------------------------------------------------------

##### SECTION 2 - Calculate mine-level profits based on global supply cost curve and scenario quantities

# Merge together datasets
supply_curve_impacts <- expand.grid(scenario = unique(scenario_data$scenario),
                                    year = unique(supply_curve_data$year)) %>%
  left_join(scenario_data) %>%
  left_join(supply_curve_data)

# Stranding indicator - takes values > 0 and < 1 for the marginal field / mine only (= 0 for stranded mines, and 1 for active mines)
supply_curve_impacts %<>%
  group_by(scenario, year) %>%
  mutate(lagged_production_cumulative = lag(production_cumulative, 1), # Lagged production variable for stranding indicator calculations
         lagged_production_cumulative = case_when(is.na(lagged_production_cumulative) ~ 0, # Replace first row in each group with 0
                                                  TRUE ~ lagged_production_cumulative),
         production_indicator = case_when(round(production_g, digits = 4) >= round(lagged_production_cumulative + regional_production, digits = 4) ~ 1, # Active but not marginal production site
                                          round(production_g, digits = 4) >= round(lagged_production_cumulative, digits = 4)
                                          & round(production_g, digits = 4) >= round(lagged_production_cumulative, digits = 4) ~ (production_g - lagged_production_cumulative) / regional_production, # Marginal production site
                                          TRUE ~ 0))

# Market price based on stranding indicator
supply_curve_impacts %<>%
  group_by(scenario, year) %>%
  arrange(scenario, year, cost) %>%
  mutate(marginal_entry = case_when(production_indicator > 0 ~ cumsum(production_indicator),
                                    TRUE ~ NA_real_),
         marginal_entry = case_when(marginal_entry == max(marginal_entry, na.rm = TRUE) ~ 1,
                                    TRUE ~ NA_real_)) %>%
  ungroup()

# Fill in price based on the marginal field
supply_curve_impacts %<>%
  group_by(scenario, year) %>%
  mutate(price = mean(cost * marginal_entry, na.rm = TRUE)) %>%
  ungroup()

# Calculate profit per tonne on each field (if any)
supply_curve_impacts %<>%
  mutate(profit = case_when(production_indicator > 0 ~ price - cost,
                            TRUE ~ 0))

# Rearrange variables
supply_curve_impacts %<>%
  select(scenario:region, price, cost, everything())

save_dated(supply_curve_impacts, "Coal_supply_curve_profits", folder = "Interim", csv = "YES")

#--------------------------------------------------------------------------------------------------

##### SECTION 3 - Chart showing supply curves, in each year, under each scenario

# Define chart function (one argument so we can apply map)
supply_curve_chart <- function(chart_scenario, chart_year) {
  
  temp <- supply_curve_impacts %>%
    mutate(bau_price = mean(ifelse(scenario == "BAU" & year == chart_year, price, NA_real_), na.rm = TRUE),
           bau_quantity = mean(ifelse(scenario == "BAU" & year == chart_year, production_g, NA_real_), na.rm = TRUE),
           scenario_quantity = mean(ifelse(scenario == chart_scenario & year == chart_year,
                                           production_g, NA_real_), na.rm = TRUE)) %>%
    filter(scenario == chart_scenario & year == chart_year) %>%
    mutate(utilised_entry_cost = case_when(production_indicator > 0 ~ cost,
                                           TRUE ~ NA_real_),
           unutilitised_entry_cost = case_when(is.na(utilised_entry_cost) ~ cost,
                                               TRUE ~ NA_real_))
  
  ggplot(temp) +
    geom_rect(aes(xmin = lagged_production_cumulative, xmax = production_cumulative,
                  ymin = 0, ymax = unutilitised_entry_cost, colour = region), fill = "white") + 
    geom_rect(aes(xmin = lagged_production_cumulative, xmax = production_cumulative,
                  ymin = 0, ymax = utilised_entry_cost, colour = region, fill = region)) +
    geom_hline(aes(yintercept = price)) + # Scenario price
    geom_hline(aes(yintercept = bau_price)) + # BAU price
    geom_vline(aes(xintercept = scenario_quantity)) + # Scenario quantity
    geom_vline(aes(xintercept = bau_quantity)) + # BAU quantity
    ggtitle(paste0(chart_scenario, " coal cost curve, ", chart_year)) +
    theme_vivid() +
    scale_x_continuous(name = "Production (Mtonnes)", expand = c(0, 0),
                       limits = c(0, ceiling(max(temp$production_cumulative, na.rm = TRUE)) + 1000)) +
    scale_y_continuous(name = "Price (2016US$/tonne)", expand = c(0, 0), limits = c(0, 80)) +
    scale_colour_vivid_house() +
    scale_fill_vivid_house()
  
  ggsave(paste0("1 - Demand destruction/Interim/Supply curves/", chart_scenario, "_", chart_year, ".png"),
         width = 22, height = 11.5, units = c("cm"))
  
}

# List of scenario-year combinations for map
scenarios <- unique(supply_curve_impacts$scenario)
years <- unique(supply_curve_impacts$year)
years <- years[years != 2016]
parameters <- expand.grid(scenario = scenarios,
                          year = years) %>%
  mutate(unique = paste0(scenario, "_", year))
parameters_vec <- as.list(parameters$unique)

# Wrapper function for call to map
loop_supply_curve_chart <- function(unique_param = NULL) {
  
  chart_scenario <- substr(unique_param, 1,
                           stop = stri_locate_last_regex(unique_param, "_") - 1)
  chart_year <- as.numeric(substr(unique_param,
                                  start = as.numeric(stri_locate_last_regex(unique_param, "_")) + 1,
                                  stop = nchar(unique_param)))
  
  supply_curve_chart(chart_scenario, chart_year)
  
}

# Run map and save outputs in Interim/Supply curves folder
#map(parameters_vec, loop_supply_curve_chart)

#--------------------------------------------------------------------------------------------------

##### SECTION 4 - NPV impacts at regional-level based on the coal supply curve

# Calculate profit per mine, by scenario, by year
supply_curve_impacts %<>%
  mutate(total_profit = profit * regional_production * production_indicator) # Only include production if mine is not stranded (remains economical) and at level determined by production indicator

save_dated(supply_curve_impacts, "Coal_supply_curve_actual_profits", folder = "Interim", csv = "YES")

npv_supply_curve_impacts <- supply_curve_impacts %>%
  filter(year != 2016) %>%
  mutate(weight = case_when(year == 2020 ~ 0.9, # NPV profit weights (2020 spans 2018 - 2022.5)
                            year == 2050 ~ 0.5, # NPV profit weights (2050 spans 2047.5 - 2050)
                            TRUE ~ 1), # NPV profit weights (all other years span 5 year windows)
         npv_profit = total_profit * weight / (1 + discount_rate) ^ (year - 2018)) %>%
  group_by(scenario, mine_ID, region) %>%
  summarise(npv_profit = sum(npv_profit)) %>%
  group_by(mine_ID, region) %>% # Create NPV BAU impacts variable (constant across scenarios)
  mutate(npv_BAU_profit = mean(ifelse(scenario == "BAU", npv_profit, NA_real_), na.rm = TRUE),
         perc_profit_impact = (npv_BAU_profit - npv_profit) / npv_BAU_profit) %>%
  ungroup()

save_dated(npv_supply_curve_impacts, "Coal_supply_curve_full_NPV_impacts", folder = "Interim", csv = "YES")

# Find regional NPV impacts (used for final calcluations)
npv_supply_curve_impacts %<>%
  group_by(scenario, region) %>%
  summarise(npv_profit = sum(npv_profit),
            npv_BAU_profit = sum(npv_BAU_profit)) %>%
  ungroup() %>%
  mutate(perc_profit_impact = (npv_BAU_profit - npv_profit) / npv_BAU_profit)

save_dated(npv_supply_curve_impacts, "Coal_supply_curve_reg_NPV_impacts", folder = "Interim", csv = "YES")

#--------------------------------------------------------------------------------------------------

##### SECTION 5 - Match supply curve regions to company data countries

country_region_matching <- tribble(~country,          ~region,
                                   "Australia",      "Australia",
                                   "Colombia",       "Colombia",
                                   "South Africa",   "South Africa",
                                   "China",          "Rest of World", #China is close enough to ROW based on observed cost data
                                   "ROW",            "Rest of World",
                                   "Philippines",    "Rest of World",
                                   "Indonesia",      "Indonesia",
                                   "Poland",         "Rest of World",
                                   "India",          "Rest of World",
                                   "Madagascar",     "Rest of World",
                                   "Mozambique",     "Rest of World",
                                   "Czech Republic", "Rest of World"
                            )

#--------------------------------------------------------------------------------------------------

##### SECTION 6 - Calculate production_share from each mine, in each model year (2018 - 50)

# 2018 production = existing production_share (year 0)
company_exposure_data %<>%
  mutate(production_share_2018 = production_share)

for(i in 2019:2050) {
  
  production_share_newyr <- rlang::sym(paste0("production_share_", i))
  production_share_oldyr <- rlang::sym(paste0("production_share_", i - 1))
  
  company_exposure_data %<>%
    mutate(!!production_share_newyr := !!production_share_oldyr * (1 - 1 / reserve_life))
  
}

# Merge in supply curve regions
company_exposure_data %<>%
  left_join(country_region_matching) %>%
  select(ISIN_code:country, region, everything())

# Save as complete production exposure profile
save_dated(company_exposure_data, "Coal_company_market_shares_full", folder = "Interim", csv = "YES")

# Sum over companies to find production relative to 2018 in each year
aggregate_company_exposure_data <- company_exposure_data %>%
  group_by(ISIN_code, company) %>%
  summarise_at(.vars = vars(starts_with("production_share_20")),
               .funs = funs(sum(.)))

# Save as complete production exposure profile
save_dated(aggregate_company_exposure_data, "Coal_company_market_shares_aggregate", folder = "Interim", csv = "YES")

# Sum over regions to find production relative to 2018 in each year
regional_company_exposure_data <- company_exposure_data %>%
  group_by(ISIN_code, company, region) %>%
  summarise_at(.vars = vars(starts_with("production_share_20")),
               .funs = funs(sum(.)))

# Save as regional production exposure profile
save_dated(regional_company_exposure_data, "Coal_company_market_shares_regional", folder = "Interim", csv = "YES")

#--------------------------------------------------------------------------------------------------

##### SECTION 4 - Interpolate profit over all years before combining with company-exposure dataset

expand_grid <- expand.grid(scenario = unique(supply_curve_impacts$scenario),
                           mine_ID = unique(supply_curve_impacts$mine_ID),
                           year = 2016:2050)

# Interpolate expanded grid 
supply_curve_impacts_full <- expand_grid %>%
  left_join(supply_curve_impacts) %>%
  group_by(scenario, mine_ID) %>%
  arrange(scenario, mine_ID, year) %>%
  fill(region) %>%
  group_by(scenario, mine_ID, region) %>%
  mutate(total_profit = approx(x = year, y = total_profit, xout = year)$y) %>%
  select(scenario:year, region, total_profit) %>%
  filter(year >= 2018)

# Summarise over mines and spread
supply_curve_impacts_full %<>%
  group_by(scenario, year, region) %>%
  summarise(total_profit = sum(total_profit)) %>%
  spread(key = "year", value = "total_profit") %>%
  rename_at(.vars = vars(`2018`:`2050`),
            .funs = funs(paste0("region_profit_", .))) %>%
  arrange(region, scenario)

# Save full regional profits
save_dated(supply_curve_impacts_full, "Coal_regional_profits_full", folder = "Interim", csv = "YES")

#--------------------------------------------------------------------------------------------------

##### SECTION 5 - Company NPV profit impacts

company_npv_impacts <- expand.grid(scenario = supply_curve_impacts_full$scenario,
                                   ISIN_code = regional_company_exposure_data$ISIN_code) %>%
  left_join(regional_company_exposure_data, by = c("ISIN_code")) %>%
  left_join(supply_curve_impacts_full, by = c("scenario", "region"))

for(i in 2018:2050) {
  
  profit_yr <- rlang::sym(paste0("profit_", i))
  production_share_yr <- rlang::sym(paste0("production_share_", i))
  region_profit_yr <- rlang::sym(paste0("region_profit_", i))
  
  company_npv_impacts %<>%
    mutate(!!profit_yr := !!production_share_yr * !!region_profit_yr)
}

# Reshape data and summarise over regions
company_npv_impacts %<>%
  select(scenario:region, starts_with("profit_20")) %>%
  group_by(scenario, ISIN_code, company) %>%
  summarise_at(.vars = vars(starts_with("profit_")),
               .funs = funs(sum(.))) %>%
  gather(key = "year", value = "profit", -(scenario:company)) %>%
  mutate(year = as.numeric(stri_extract_all_regex(year, "[0-9]+"))) %>%
  arrange(ISIN_code, year, scenario)

# Calculate NPV profit, in each year
company_npv_impacts %<>%
  mutate(npv_profit = profit / (1 + discount_rate) ^ (year - 2018)) %>%
  group_by(scenario, ISIN_code, company) %>%
  summarise(npv_profit = sum(npv_profit)) %>%
  group_by(ISIN_code, company) %>%
  mutate(npv_BAU_profit = mean(ifelse(scenario == "BAU", npv_profit, NA_real_), na.rm = TRUE),
         perc_profit_impact = (npv_BAU_profit - npv_profit) / npv_BAU_profit) %>%
  ungroup() %>%
  arrange(ISIN_code, scenario)

# Save full regional profits
save_dated(company_npv_impacts, "Coal_company_NPV_impacts", folder = "Output", csv = "YES")
