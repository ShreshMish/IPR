##### Project code:       Net-Zero Toolkit for modelling the financial impacts of low-carbon transition scenarios
##### Date of last edit:  25/06/2019
##### Model author:       Robert Ritz
##### Code author:        Shyamal Patel
##### Dependencies:       Combined model panel generated by the Combine_datasets.R script
##### Notes:              None
##### Called by:          N/A

#--------------------------------------------------------------------------------------------------

##### SECTION 1 - Housekeeping and data read in ----

# Define master_folder and source utils file which contains useful functions
main_save_folder <- "3_Cost_and_competition"
source("utils.R")

# Combined model dataset
model_data <- readRDS("3_Cost_and_competition/Interim/Cleaned_model_panel.rds")

# Source the functions which run the model
source("5_Unit_tests/Dummy_model.R")

#--------------------------------------------------------------------------------------------------

##### SECTION 1a - Generate the data ----

# parameters 

parameter_data <- tibble(discount_rate = 0.0575, 
                         competition = 0.5,
                         product_differentiation = "change",  #JC: as long as this isn't B.0, it will iterate correctly
                         num_firms = "ON", #Changed from perfect competition (PC = 10^9 firms) to "ON" (endogenous number of firms based on H index)
                         firm_closure = "ON",
                         industry_cost_pass_through = "change", # this is changed in the model
                         elasticity = "change", #JC: as long as this isn't B.0, it will iterate correctly
                         stranding = "OFF",
                         green_upside = "OFF",
                         power_model = "OFF",
                         abatement_opportunities = "ON",
                         cost_pass_through = "ON",
                         sales_impact = "ON",
                         quantity_reallocation = 0.5,  # Reset to default values
                         winsorise_scope_1 = "ON", # Winsorisation of scope 1 emissions intensity [overrides quantiles below]
                         winsorise_qlow = 0.05,  # Quantile assumptions for Winsorisation
                         winsorise_qhigh = 0.95,  # Quantile assumptions for Winsorisation
                         profit_cap = 0.75, # Cap on how much profit subsidiaries can make relative to BAU
                         profit_cap_weight = 0.8, # Weight on cap (80% = 0.8 * profit_cap + 0.2 * original NPV profit)
                         n = 100) # determines number of companies to choose

# new dataset - choose one scenario, define artificial data

clean_data <- 
  filter(model_data, scenario == "2DS_Balanced_Transformation") # JC: can use Paris_NDCs as baseline check

artificial_data <- clean_data %>%
  mutate(market_cap_2017 = median(market_cap_2017), 
         profit_impact_pct = median(profit_impact_pct),
         revenue_2017 = median(revenue_2017), 
         net_income_2017 = median(net_income_2017), 
         net_income_margin = median(net_income_margin),
         corporation_tax_rate = median(corporation_tax_rate),
         co2_factor = runif(1, min = 0.5, max = 1.5),
         co2_scope_1_2017 = median(co2_scope_1_2017)*co2_factor,
         parent_market == "Artificial") %>%
  sample_n(size = parameter_data$n)

# define elasticities 
temp = 1:40
elas = temp/10

#--------------------------------------------------------------------------------------------------

##### SECTION 2 - Apply Robert Ritz function to the combined model dataset ----

## JC: it would be good to have an option to generate prod.dff values here based on desired CPT rates

prod_diff <- c(0.00001, 0.002, 0.005, 0.01, 0.018, 0.035, 0.085, 0.5) # lifted from CPT rate calculations

# defines function to map model

model_wrap <- function(x, y) {
  
  temp <- parameter_data %>%
    mutate(elasticity = x,
           product_differentiation = y) # replaces elasticity to mapped value
  
  print(paste0("elasticity is", " ", x, " ", "prod. differentiation is", " ", y)) # helps keep track of progress
  
  dummy_model(artificial_data, temp, "", variables = quo(c("market_cap_2017", starts_with("profit_post_closure_pre_tax"),
                                                           starts_with("profit_post_closure_post_tax"),
                                                           starts_with("profit_npv_post_closure_post_tax"),
                                                           starts_with("revenue"))))
}

# generate results

artificial_results <- map(cross2(elas, prod_diff), wrapper_2 <- function(x) {model_wrap(x[[1]], x[[2]])}) %>%
          bind_rows() %>%
          mutate(a_term = 1 / (1 + parameter_data$competition - product_differentiation),
                 b_term = 1 - product_differentiation,
                 c_term = (parameter_data$competition * product_differentiation * (parameter_data$n)) / 
                          (1 + parameter_data$competition + product_differentiation * ((parameter_data$n) - 1)),
                 cpt = a_term*(b_term + c_term)) # add floor to this function to get regular intervals

# SECTION 1c - Summarise and present results  ------------


summarise_artificial <- function(...) {
  
  summarise_vars <- enquos(...)
  
  temp <- artificial_results %>% # 
    group_by(elasticity, scenario, !!!(summarise_vars)) %>%
    summarise_at(vars(index, index_cap),
                 funs(list(quantile(., probs = c(0.05, 0.1, 0.5, 0.9, 0.95))))) %>%
    mutate_at(vars(index, index_cap),
              funs(map_chr(., paste, collapse = ","))) %>%
    separate(index, into = c("index_p5", "index_p10", "index", "index_p90", "index_p95"), sep = ",") %>%
    separate(index_cap, into = c("index_cap_p5", "index_cap_p10", "index_cap", "index_cap_p90", "index_cap_p95"), sep = ",") %>%
    mutate_at(vars(contains("index")),
              funs(as.numeric(.)))
}

artificial_sum <- summarise_artificial(cpt)


# Draft 3d chart - JC to finesse

library(plotly)

# generates surface chart

surface <- artificial_sum %>%
  select(elasticity, cpt, index) %>%
  spread(key = cpt, value = index)
  surface$scenario <- NULL
  surface$elasticity <- NULL
q <- data.matrix(surface) # turn data into a data frame

surface_chart <- plot_ly(showscale = FALSE) %>%
  add_surface(z = ~q)

# heatmap

heatmap <- artificial_sum %>%
  select(elasticity, cpt, index)

ggplot(heatmap, aes(x = cpt, y = elasticity, fill = index)) + 
  geom_tile()

# marker chart - for info

# artificial_sum %>% plot_ly(type = 'scatter3d', x = ~elasticity, y = ~cpt, z = ~index, mode = 'markers')


